**********************************（5―20）*****************************

1.nslookup 通过域名查ip

2. ISO/OSI参考模型：

！物理层：电气特性，设备规范，RJ―45。传输数据的单位是BIT，这一层的设备有网卡。

！数据链路层：数据成帧 ， 来源去向，差错检测
  设备是交换机，
  传输数据的单位是帧（添头加尾成帧）
  链路：没有其他设备的一段线路
  能收到哪些数据？发给自己的，广播的数据，组播数据
（用的物理地址）

！网络层：选择最佳路径将数据从源端送到目的端。IP划分
  设备：路由器    数据单位：包
  负责将数据尽可能的送到目的地，但是不保证一定送达。

！传输层：负责将数据交给具体的进程。端口。保证数据送达。流量控制（根据对方的接受速率，来匹配的发送数据）。拥塞控制（根据网络上的拥塞程度来控制传输数据的速度）
  UDP：不保证可靠送达		TCP：保证可靠
  IP：					ICMP：报错的协议（PING用的协议）
  ttl:每过一个服务器，ttl-1 ，Linux默认是64，windows默认是128，Unix默认是255（Linux下ping IP 看ttl可以判断其服务器的类型 ）

！会话层：建立连接，过程管理，断开连接。
netstat -n   // 查看会话 
netstat -nb  //linux是p，windows是b  看会话是哪个进程的

！表示层：加密，压缩，改变字节序
（手机是ARM处理器，大小端可以指定，X86是小端）

！应用层：凡是能产生网络流量的进程，都是应用层的


网络故障排除：
	从底层向上层
arp -a
arp -s ip MAC 手动设置MAC
Ping /?  帮助文档
ping -i 数字 www.baidu.com  数字指定经过多少个路由器
pathping  linux下没有

物数网传会表应		应表会传网数物
数网传应			应传网数
_____________________________________________________________
应用层      | 		|
表示层      | 应用层	|   软件应用 HTTP,FIP,POP3,SMTP,DNS
会话层______|___________|_____________________________________
传输层______|_传输层___	|     内核  TCP,UDP,IP,ICMP,ARP
网络层______|_网络层_____|____________________________________
数据链路层	|		|	驱动及操作
物理层	______|数据链路层__|____________________________________


上网的形式：
B/S:
C/S:
P2P:

网络协议栈！
层层封装，层层解封

《TCP/IP详解》



*******************************  6_3  ***********************************

！recvfrom()调用没信号发过来时会阻塞

！客户机不用绑定端口号，操作系统会自动分配一个端口号

！read()返回0，表读到了EOF

！IP写0时，处理所有IP，0涵盖了此机器所有网卡的ip

！netstat -anp
  netstat -anp | less (less可以上下翻动，打开大文件时，会非常快。延时加载）
 netstat -anp 9090

！通常一个端口号不能同时被两个进程绑定，端口号区分进程（用fork()可以不同进程绑定同一个端口号）

！桥接模式：物理机和虚拟机在同一个网段中，（相当虚拟机是一台真实的物理设备）
  NAT模式：

！调试网络程序：

方法一：（局域网）
1.vmware 网络连接方式设置成桥接模式
2.把两台物理机连接到同一个局域网中
3.手动关闭防火墙
	(a) root
	(b) centos 6 : service iptables stop
	(7) centos 7 : service firewalld stop

方法二：（云服务器）



！<scp>远程拷贝	
scp test@114.115.172.211:/home/test/client.c ./
./a.out 114.115.172.211 9090

！sh deploy.sh    //shell脚本

！Linux ssh 添加信任关系

！inet_ntoa()不是线程安全函数（内部有静态缓冲区），推荐使用inet_ntop();

！random_r()是可重入的random版本。

！



****************************** 6_7  ***********************************



****************************** 6_8 ***********************************

fiddler

GET/POST的区别：GET一般没有boby，POST一般 有boby

！http请求格式
：heard：若干行的键值对，每一行是一个键值对，键值对名和键值之间用：分割
	空行只有一个\n，作为header的结束标记
，首行： GET/POST URL http版本号
，user_agent
,referer 前一个网页，识别跳转来源
,https(可以避免运营商劫持)
,content_type:描述boby的格式，常见用法和query_string的格式相同
,content_lenght:boby中的数据的长度

：boby:



！http响应格式：
:head:
，首行：版本号  状态码（成功还是失败 200 404） 状态码描述
，set_cookie:将cookie保存再浏览器当中

：boby:boby的数据格式取决于content_type，往往是html

http/1.1 302 found0
location:http:www.baidu.com
//跳到百度

（
	序列化/反序列化
	xml json
）




///************************** 7_1 *****************************///
epoll
//生命周期随进程；红黑树，用于活跃客户端比较少的情况；epoll并没有用内存映射机制。

epoll_creat(int size);
//int size为了向前兼容；创建一个epoll句柄，用完后close（）之。

epoll_ctl（int epfd,int op,int fd,struct epoll_event* event);
//epoll的注册函数

epoll_wait()
//收集在epoll监控的事件中已经发送的事件


（默认的）
水平触发：再次调用epoll_wait,epoll_wait就会就会立刻返回，提示还是同一个没读完的文件描述符读就绪。
（需使用非阻塞轮询的方式读数据。）

（需要设置选项 EPOLLET）（又叫高速模式）
边缘触发：再次调用epoll_wait,epoll_wait不会返回，此时缓冲区中还剩1k数据就不能立刻被读取到，就需要等到对应的socket再次收到数据触发读就绪，才有机会把之前残留的数据读出来。
边缘触发方式要求一旦读就绪，就必须一次读出数据。











/********************** 网络编程复习 ***************************/
――――――――――――――网络基础：
――基本背景：
――网络中的协议栈：7层，tcp/ip 四层/五层都可以
		物数网传应；
――封装和分用：（好处）具体实现对使用者透明，会用就好
		   （流程）发/收快递
――TCP/IP协议：   资料：图解TCP/IP;图解HTTP；TCP/IP详解（卷一）；TCP/IP详   				解（卷二）；C++泛型编程与模板（STL使用）
		      应用层：如何自定制应用层协议：
				1.根据需求把信息烤炉清楚；
				2.按照一定格式，把结构化数据构成字符串（序列					  化）；（反序列化）
			        HTTP协议：
				1.抓包工具
				2.报文格式：首行:方法：GET,POST,PUT,DELETE,HEAD
						    URL:服务器地址（ip）
							  端口号（默认80）
							  带目录层次的路径（相对路								  径，相对于HTTP服务器根目								  录）
							  查询参数;若干键值对
						    版本号：
						header：格式：
							  重点理解的header：
							（User-agent,refer,cookie,）
							(Content-Type,Content-Length)
						空行：header的结束标志
						body:

响应：首行：版本号
		状态吗：
		状态吗描述信息：
	header:
		格式：和请求一样
		重点理解的header;set―cookie(和cookie配合使用)
					Content-Type：决定了body的格式（txt,html）
					Content-length：

	空行：header结束标记
	body:HTML格式数据
和粘包问题的关系：分隔符：空行

传输层：基本功能：点到点的数据传输
	重要概念:端口号（应该交给哪个进程处理）
	核心协议：UDP,TCP
UDP:长度：2个字节，udp数据报最大64kb

tcp核心特性：三次，四次
  如果服务器大量TIME-wait状态，此时，服务器是主动断开连接的一方，。。。

确认应答：tcp可靠性的核心保证
超时重传：
滑动窗口：提高传输效率
	窗口大小：不等待ACK的前提下，能够批量发送的数据量
	窗口越大，吞吐量越大，
	丢包怎么办：快速重传
流量控制：根据接收端缓冲区空闲大小决定发送方的窗口大小
拥塞控制：根据网络拥堵程度：慢开始
延时应答：提高传输效率：收到数据不立刻返回ACK，而是等一会返回，给接收端留出了时间来处理缓冲区的数据
捎带应答：提高传输效率：
粘包问题：应用层数据没有读取完整：应用层数据之间加上明显的边界
							定义好数据大小
TCP异常断开连接的问题：进程异常中止（也有四次挥手）
			   机器关机（也先杀进程）
			   机器掉电/剪断网线（对方尝试写，失败）
						（尝试读，有保活机制）

udp  vs  tcp
	udp可以用于广播TCP不可以
	TCP内存开销大于UDP
	UDP传输效率大于tcp
	TCP对应用层数据报大小没有要求，udp有64kb限制。
	经典问题：udp可靠传输


核心功能：地址管理：网络号，主机号
			CIDR
			特殊的IP地址
			动态分配IP地址DHCP
			NAT机制（NAPT?）
			IPV6:
	  路由选择：路由表
			


数据链路层：
核心功能：网络上相邻两个节点之间的数据传输
以太网数据帧：mac地址：标识一台主机设备
				6字节
				MTU：数据链路层的数据帧长度上限对于以太网是1500
				对IP的影响：IP数据报分包
				对UDP的影响：包分的多了，容易丢
				对TCP：MSS：IP数据报不分包的情况下，tcp报文长度
		ARP:通过广播的形式，获取到局域网中所有IP和MAC的映射关系
		RARP;
		
		DNS:
		NAT:
		ICMP:




――――――――――――――socket api :



SOCKET API:
常用的 api：socket:创建文件描述符
		bind:将文件描述符与IP+端口号关联起来
			服务器一定要绑定端口号，客户端最好不要绑定端口号
		listen:tcp服务器专属
			把一个socket变成被动模式，允许其他客户端来建立连接
			第二个参数的含义：门口等位置的板凳个数
		accept:TCP服务器专属，把内核中建立好的连接获取到用户代码中
			返回了一个新的文件描述符，用于和客户端交互
		connect:tcp客户端专属：用于建立连接,负责三次握手
		read/write
		send/recv
		sendto/recvfrom

echo_server:回显服务器
UDP
TCP单连接：
TCP多进程：
TCP多线程：
TCPselect:
TCPepoll:



高级IO：
阻塞，非阻塞，信号驱动，io多路复用，异步

io多路复用:一个线程来监控多个文件描述符的就绪状态
select：缺点; 
epoll：优点
poll:




***************************** HTTP服务器 ******************************


一・若干个和业务具体相关的CGI程序

CGI:标准/协议(通用网关接口)（20年前的东西）
优点：完成解耦，让通用的HTTP服务器和业务完全的解耦合
CGI不一定用C语言来实现，CGI程序可以用任何编程语言实现


根据不同的业务，来分别实现不同的CGI程序
读取HTTP服务器交给她的参数，根据自身业务，计算生成响应数据，交还给框架

HTTP服务器框架创建子进程，子进程根据所请求的CGI程序的路径（HTTP请求中的url_path），进行程序替换。CGI程序就可以开始计算了

框架怎么将参数传给CGI：进程间通信中的管道+环境变量
CGI程序计算的结果通过管道写回给HTTP服务器框架





二・通用的HTTP服务器框架：

通用：与业务无关

Nginx/httpd(apache)(通用的HTTP框架)

具体功能：
1.服务器初始化（socket初始化）
2.处理HTTP请求
	从socket中读取数据，并且按照HTTP协议格式解析数据
	根据输入的请求不同，决定按静态页面还是动态页面处理
	若是静态页面，直接将服务器上的文件返回到客户端
	若是动态页面，就将输入信息交给相应的CGI程序，由cgi来计算生成响应，并	    交还给服务器框架，由框架返回到客户端。


三・详细设计（模块的实现细节）

  
































































































































































































































































































































































































































































































































